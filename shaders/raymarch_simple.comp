#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Buffers and Textures
// ============================================================================

// Output image
layout(rgba16f, binding = 0) writeonly uniform image2D uOutputImage;

// ============================================================================
// Uniforms
// ============================================================================

// Camera
uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

// Scene
uniform vec4 uBackgroundColor;

// Viewport
uniform int uViewportWidth;
uniform int uViewportHeight;

// Raymarching parameters
uniform int uMaxSteps;
uniform float uMaxDistance;
uniform float uSurfaceEpsilon;
uniform float uStepRatio;

// Fractal parameters
uniform vec3 u_paramA;
uniform vec3 u_paramB;
uniform vec3 u_paramC;
uniform vec3 u_paramD;
uniform float _LEVELS;

#include "include/palette.glsl"
#include "include/distance.glsl"

vec2 sphere_sd (vec3 p, float s)
{
    return vec2(length(p) - s, 0.0);
}
vec2 mapScene(vec3 p)
{
    // return tglad(p);
    return sphere_sd(p, 1.0);
}

// ============================================================================
// Ray Generation
// ============================================================================

vec3 computeRayDirection(ivec2 pixel) {
    vec2 resolution = vec2(float(uViewportWidth), float(uViewportHeight));
    vec2 uv = (vec2(pixel) + vec2(0.5)) / resolution;
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    return normalize(
        uCameraForward +
        ndcX * uTanHalfFov * uAspect * uCameraRight +
        -ndcY * uTanHalfFov * uCameraUp
    );
}

// ============================================================================
// Shading
// ============================================================================

vec3 shade(vec3 hitPos, float orbit) {
    vec3 normal = estimateNormal(hitPos);
    vec3 lightDir = normalize(vec3(0.4, 0.8, 0.2));
    float diffuse = max(dot(normal, lightDir), 0.0);
    vec3 baseColor = palette(orbit);
    return baseColor * diffuse + baseColor * 0.1;
}

// ============================================================================
// Simple Per-Pixel Raymarcher
// ============================================================================

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    // Bounds check
    if (pixel.x >= uViewportWidth || pixel.y >= uViewportHeight) {
        return;
    }

    // Generate ray for this pixel
    vec3 rayDir = computeRayDirection(pixel);
    vec3 rayOrigin = uCameraPos;
    float depth = 0.0;

    // Raymarch
    float i = 0;
    bool hitSurface = false;
    float orbit = 0.0;

    for (; i < uMaxSteps; i++) {
        vec3 pos = rayOrigin + rayDir * depth;
        vec2 df_result = mapScene(pos);
        float dist = df_result.x;
        orbit = df_result.y;

        if (dist < 0.0001) {
            hitSurface = true;
            break;
        }

        depth += dist * uStepRatio;

         if (depth >= uMaxDistance) {
             break;
         }
    }

    // Compute color
    vec3 color;
    if (hitSurface) {
        vec3 hitPos = uCameraPos + rayDir * depth;
        float iter_scale = 1 -  (float(i) / float(uMaxSteps));
        iter_scale = pow(iter_scale, 3);
        color = iter_scale * vec3(1.0);
    } else {
        color = uBackgroundColor.rgb;
    }

    // Write to output
    imageStore(uOutputImage, pixel, vec4(color, 1.0));
}
