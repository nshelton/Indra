#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Buffers and Textures
// ============================================================================

// Depth output (single channel R32F)
layout(r32f, binding = 0) writeonly uniform image2D uDepthOutput;

// ============================================================================
// Uniforms
// ============================================================================

// Camera
uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

// Viewport
uniform int uViewportWidth;
uniform int uViewportHeight;

// Raymarching parameters
uniform int uMaxSteps;
uniform float uMaxDistance;
uniform float uSurfaceEpsilon;
uniform float uStepRatio;

// Fractal parameters
uniform vec3 u_paramA;
uniform vec3 u_paramB;
uniform vec3 u_paramC;
uniform vec3 u_paramD;
uniform float _LEVELS;

#include "include/palette.glsl"
#include "include/distance.glsl"

vec2 sphere_sd (vec3 p, float s)
{
    return vec2(length(p) - s, 0.0);
}

vec2 mapScene(vec3 p)
{
    return tglad(p);
}

// ============================================================================
// Ray Generation
// ============================================================================

vec3 computeRayDirection(ivec2 pixel, ivec2 resolution) {
    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(resolution);
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    return normalize(
        uCameraForward +
        ndcX * uTanHalfFov * uAspect * uCameraRight +
        -ndcY * uTanHalfFov * uCameraUp
    );
}

// ============================================================================
// Base Level Depth Raymarcher (from scratch)
// ============================================================================

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(uDepthOutput);

    // Bounds check
    if (pixel.x >= resolution.x || pixel.y >= resolution.y) {
        return;
    }

    // Generate ray for this pixel at the current mip resolution
    // Each mip level covers the full viewport, just at different resolutions
    vec3 rayDir = computeRayDirection(pixel, resolution);
    vec3 rayOrigin = uCameraPos;
    float depth = 0.0;

    // Raymarch from scratch
    bool hitSurface = false;

    for (int i = 0; i < uMaxSteps; i++) {
        vec3 pos = rayOrigin + rayDir * depth;
        vec2 df_result = mapScene(pos);
        float dist = df_result.x;

        if (dist < uSurfaceEpsilon) {
            hitSurface = true;
            break;
        }

        depth += dist * uStepRatio;

        if (depth >= uMaxDistance) {
            depth = uMaxDistance;
            break;
        }
    }

    // Store depth (negative for misses if you want to distinguish them)
    imageStore(uDepthOutput, pixel, vec4(depth, 0, 0, 0));
}
