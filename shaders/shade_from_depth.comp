#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Buffers and Textures
// ============================================================================

// Depth input (from raymarching passes)
layout(r32f, binding = 0) readonly uniform image2D uDepthMap;

// Color output
layout(rgba16f, binding = 1) writeonly uniform image2D uColorOutput;

// ============================================================================
// Uniforms
// ============================================================================

// Camera
uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

// Scene
uniform vec4 uBackgroundColor;

// Viewport
uniform int uViewportWidth;
uniform int uViewportHeight;

// Raymarching parameters
uniform float uMaxDistance;
uniform float uSurfaceEpsilon;
uniform float uSeed;

// Fractal parameters
uniform vec3 u_paramA;
uniform vec3 u_paramB;
uniform vec3 u_paramC;
uniform vec3 u_paramD;
uniform float _LEVELS;

#include "include/palette.glsl"
#include "include/distance.glsl"


// ============================================================================
// Normal Estimation
// ============================================================================

vec3 estimateNormal(vec3 p, float d)
{
    const vec3 e = vec3(1, -1, 0);
    const float h = exp(-uSurfaceEpsilon) * d;
    return normalize(
        e.xyy * mapScene(p + e.xyy * h).x +
        e.yyx * mapScene(p + e.yyx * h).x +
        e.yxy * mapScene(p + e.yxy * h).x +
        e.xxx * mapScene(p + e.xxx * h).x
    );
}

// ============================================================================
// Ray Generation
// ============================================================================

vec3 computeRayDirection(ivec2 pixel, ivec2 resolution) {
    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(resolution);
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    return normalize(
        uCameraForward +
        ndcX * uTanHalfFov * uAspect * uCameraRight +
        -ndcY * uTanHalfFov * uCameraUp
    );
}

float rand(vec2 px, float seed)
{
    float result = fract(sin(seed / 1000.0f * dot(px, vec2(2.998f, 7.133f))) * 3119.5453f);
    return result;
}

#define PI 3.14159265359

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) - 0.5;
}

float rand(float c)
{
    vec2 co = vec2(c, c);
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) - 0.5;
}

// PRNG function
float nrand(vec2 uv, float salt)
{
    uv += vec2(salt, uSeed);
    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
}


//Random number [0:1] without sine
#define HASHSCALE1 .16180339887
float hash(float p)
{
	vec3 p3  = fract(vec3(p) * HASHSCALE1);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

vec3 randomSphereDir(vec2 uv)
{
    float u = nrand(uv, 10) * 2 - 1;
    float theta = nrand(uv, 11) * PI * 2;
    float u2 = sqrt(1 - u * u);
    return vec3(u2 * cos(theta), u2 * sin(theta), u);
}

vec3 randomHemisphereDir(vec3 dir, float i)
{
	vec3 v = randomSphereDir( vec2(rand(i + 1.0), rand(i + 2.0)) );
	return v * sign(dot(v, dir));
}


float sdot(vec3 x, vec3 y, float f)
{
    return clamp(dot(x, y) * f, 0.0, 1.0);
}

float calc_energy(vec3 color)
{
    return dot(color, vec3(1.0 / 3.0));
}


mat3 GetTangentSpace(vec3 normal)
{
    // Choose a helper vector for the cross product
    vec3 helper = vec3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = vec3(0, 0, 1);

    // Generate vectors
    vec3 tangent = normalize(cross(normal, helper));
    vec3 binormal = normalize(cross(normal, tangent));
    return mat3(tangent, binormal, normal);
}

vec3 SampleHemisphere(vec3 normal, float alpha)
{
    // Sample the hemisphere, where alpha determines the kind of the sampling
    float cosTheta = pow(rand(gl_GlobalInvocationID.xy, uSeed * 87), 1.0f / (alpha + 1.0f));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
    float phi = 2 * PI * rand(gl_GlobalInvocationID.xy, uSeed * 1131.7);
    vec3 tangentSpaceDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);

    // Transform direction to world space
    return GetTangentSpace(normal) * tangentSpaceDir;
}

// ============================================================================
// Shading Pass (read depth, compute color)
// ============================================================================


vec3 shadePointSimple(vec3 rayOrigin, vec3 rayDir, float depth) {
    // Simple shading based on normal and albedo
    vec3 position = rayOrigin + rayDir * depth;
    vec3 normal = estimateNormal(position, depth);
    vec2 world_Sample = mapScene(position);
    vec3 albedo = palette(world_Sample.y);

    float diffuse = sdot(normal, -rayDir, 1.0f);

    return albedo * diffuse;
}

// ============================================================================
// Path Tracing Helper Functions
// ============================================================================

struct RayHit {
    bool hit;
    float distance;
    vec3 position;
    vec3 normal;
    vec3 albedo;
};

// Trace a ray through the scene and return hit information
RayHit traceRay(vec3 origin, vec3 direction, int maxSteps) {
    RayHit result;
    result.hit = false;
    result.distance = 0.0;

    // Small offset to avoid self-intersection
    float t = 0.001;

    for (int step = 0; step < maxSteps; step++) {
        vec3 pos = origin + direction * t;
        vec2 df_result = mapScene(pos);
        float dist = df_result.x;

        if (dist < 0.001) {
            result.hit = true;
            result.distance = t;
            result.position = pos;
            result.normal = estimateNormal(pos, t);
            result.albedo = palette(df_result.y);
            break;
        }

        t += dist;

        if (t >= uMaxDistance) {
            break;
        }
    }

    return result;
}

// Cosine-weighted hemisphere sampling for diffuse surfaces
vec3 SampleCosineHemisphere(vec3 normal, vec2 seed) {
    float u1 = nrand(seed, 10);
    float u2 = nrand(seed, 11);

    // Cosine-weighted sampling
    float r = sqrt(u1);
    float theta = 2.0 * PI * u2;

    vec3 tangentDir = vec3(r * cos(theta), r * sin(theta), sqrt(max(0.0, 1.0 - u1)));

    // Transform to world space
    return GetTangentSpace(normal) * tangentDir;
}

// Multi-bounce path tracing
vec3 shadePoint(vec3 rayOrigin, vec3 rayDir, float depth) {
    // 2-3 bounces gives nice AO look
    const int MAX_BOUNCES = 3;

    // Track light attenuation
    vec3 throughput = vec3(1.0);
    // Accumulated light
    vec3 radiance = vec3(0.0);

    // First hit is given (from depth map)
    vec3 position = rayOrigin + rayDir * depth;
    vec3 normal = estimateNormal(position, depth);
    vec2 world_Sample = mapScene(position);
    vec3 albedo = palette(world_Sample.y);

    // Start path tracing from first bounce
    // Offset to avoid self-intersection
    vec3 currentOrigin = position + normal * 0.002;

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
        // Generate random direction in hemisphere
        vec2 seed = gl_GlobalInvocationID.xy + vec2(bounce * 13.7, bounce * 27.3);
        vec3 bounceDir = SampleCosineHemisphere(normal, seed);

        // Trace the bounce ray
        // Fewer steps per bounce for performance
        RayHit hit = traceRay(currentOrigin, bounceDir, 64);

        if (hit.hit) {
            // Update throughput with albedo (energy absorbed by surface)
            throughput *= (bounce == 0) ? albedo : hit.albedo;

            // Accumulate indirect lighting (simple diffuse term)
            float ndotl = max(dot(hit.normal, -bounceDir), 0.0);

            // Setup for next bounce
            currentOrigin = hit.position + hit.normal * 0.002;
            normal = hit.normal;
            albedo = hit.albedo;
        } else {
            // Ray escaped to sky - add sky contribution
            radiance += throughput * uBackgroundColor.rgb;
            break;
        }

        // Russian roulette for path termination (optional performance optimization)
        float rrProbability = max(throughput.r, max(throughput.g, throughput.b));
        if (rrProbability < 0.1 && bounce > 1) {
            break;
        }
    }

    // If all bounces hit geometry, add some ambient term (prevents pure black)
    if (length(radiance) < 0.001) {
        // Small ambient
        radiance = throughput * 0.05;
    }

    return radiance;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(uColorOutput);

    // Bounds check
    if (pixel.x >= resolution.x || pixel.y >= resolution.y) {
        return;
    }

    float depth = imageLoad(uDepthMap, pixel).r;

    if (depth <= 0.0 || depth > uMaxDistance) {
        imageStore(uColorOutput, pixel, uBackgroundColor);
    }
    else {
        vec3 rayOrigin = uCameraPos;
        vec3 rayDir = computeRayDirection(pixel, resolution);

        vec3 color = shadePoint(rayOrigin, rayDir, depth);
        // vec3 color = shadePointSimple(rayOrigin, rayDir, depth);

        // contrast adjustment
        // color = pow(color, vec3(7));

        // store depth in the alpha channel to do TAA later
        imageStore(uColorOutput, pixel, vec4(color, depth));
    }
}
