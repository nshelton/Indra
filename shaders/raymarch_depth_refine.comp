#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Buffers and Textures
// ============================================================================

// Parent depth (read from coarser level)
layout(r32f, binding = 0) readonly uniform image2D uParentDepth;

// Current depth output (write to this level)
layout(r32f, binding = 1) writeonly uniform image2D uDepthOutput;

// ============================================================================
// Uniforms
// ============================================================================

// Camera
uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

// Viewport
uniform int uViewportWidth;
uniform int uViewportHeight;

// Raymarching parameters
uniform int uMaxSteps;
uniform float uMaxDistance;
uniform float uSurfaceEpsilon;
uniform float uStepRatio;

// Fractal parameters
uniform vec3 u_paramA;
uniform vec3 u_paramB;
uniform vec3 u_paramC;
uniform vec3 u_paramD;
uniform float _LEVELS;

#include "include/palette.glsl"
#include "include/distance.glsl"

vec2 mapScene(vec3 p)
{
    return tglad(p);
}

// ============================================================================
// Ray Generation
// ============================================================================

vec3 computeRayDirection(ivec2 pixel, ivec2 resolution) {
    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(resolution);
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    return normalize(
        uCameraForward +
        ndcX * uTanHalfFov * uAspect * uCameraRight +
        -ndcY * uTanHalfFov * uCameraUp
    );
}

// ============================================================================
// Refinement Level Depth Raymarcher (continue from parent)
// ============================================================================
void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(uDepthOutput);

    // Bounds check
    if (pixel.x >= resolution.x || pixel.y >= resolution.y) {
        return;
    }

    // Read parent depth (nearest neighbor upsampling)
    ivec2 parentPixel = pixel / 2;
    float parentDepth = imageLoad(uParentDepth, parentPixel).r;

    // Generate ray for this pixel
    vec3 rayDir = computeRayDirection(pixel, resolution);
    vec3 rayOrigin = uCameraPos;

    // Continue raymarching from parent depth
    float depth = parentDepth;
    bool hitSurface = false;

    for (int i = 0; i < uMaxSteps; i++) {
        vec3 pos = rayOrigin + rayDir * depth;
        vec2 df_result = mapScene(pos);
        float dist = df_result.x;

        if (dist < 0.0001) {
            hitSurface = true;
            break;
        }

        depth += dist * uStepRatio;

        if (depth >= uMaxDistance) {
            depth = uMaxDistance;
            break;
        }
    }

    // Store refined depth
    imageStore(uDepthOutput, pixel, vec4(depth, 0, 0, 0));
}
