#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Buffers and Textures
// ============================================================================

// Depth input (from raymarching passes)
layout(r32f, binding = 0) readonly uniform image2D uDepthMap;

// Color output
layout(rgba32f, binding = 1) writeonly uniform image2D uColorOutput;

// ============================================================================
// Uniforms
// ============================================================================

// Camera
uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

// Scene
uniform vec4 uBackgroundColor;

// Viewport
uniform int uViewportWidth;
uniform int uViewportHeight;

// Raymarching parameters
uniform float uMaxDistance;

// Fractal parameters
uniform vec3 u_paramA;
uniform vec3 u_paramB;
uniform vec3 u_paramC;
uniform vec3 u_paramD;
uniform float _LEVELS;

#include "include/palette.glsl"
#include "include/distance.glsl"

vec2 mapScene(vec3 p)
{
    return tglad(p);
}

// ============================================================================
// Normal Estimation
// ============================================================================

vec3 estimateNormal(vec3 p)
{
    const vec3 e = vec3(1, -1, 0);
    const float h = 0.001;
    return normalize(
        e.xyy * mapScene(p + e.xyy * h).x +
        e.yyx * mapScene(p + e.yyx * h).x +
        e.yxy * mapScene(p + e.yxy * h).x +
        e.xxx * mapScene(p + e.xxx * h).x
    );
}

// ============================================================================
// Ray Generation
// ============================================================================

vec3 computeRayDirection(ivec2 pixel, ivec2 resolution) {
    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(resolution);
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    return normalize(
        uCameraForward +
        ndcX * uTanHalfFov * uAspect * uCameraRight +
        -ndcY * uTanHalfFov * uCameraUp
    );
}

// ============================================================================
// Shading Pass (read depth, compute color)
// ============================================================================

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(uColorOutput);

    // Bounds check
    if (pixel.x >= resolution.x || pixel.y >= resolution.y) {
        return;
    }

    // Read final depth from depth pyramid (mip level 0)
    float depth = imageLoad(uDepthMap, pixel).r;

    // DEBUG: Visualize depth directly
    vec3 color = vec3(depth / uMaxDistance);  // Normalize depth to [0,1]

   // ORIGINAL SHADING CODE - COMMENTED OUT FOR DEBUG
    // Generate ray
    vec3 rayOrigin = uCameraPos;
    vec3 rayDir = computeRayDirection(pixel, resolution);

    // Check if ray hit surface (depth less than max distance)
    if (depth < uMaxDistance - 0.01) {
        // Hit! Compute surface position
        vec3 surfacePos = rayOrigin + rayDir * depth;

        // Get orbit trap or distance field info for coloring
        vec2 sceneData = mapScene(surfacePos);
        float orbit = sceneData.y;

        // Compute normal for lighting
        vec3 normal = estimateNormal(surfacePos);
        vec3 lightDir = normalize(vec3(0.4, 0.8, 0.2));
        float diffuse = max(dot(normal, lightDir), 0.0);

        // Use palette-based coloring like in original
        vec3 baseColor = palette(orbit/10);
        color = baseColor * diffuse + baseColor * 0.1;

        // Alternative: Simple white shading (uncomment if you prefer)
        // color = vec3(diffuse * 0.8 + 0.2);
    } else {
        // Miss - use background
        color = uBackgroundColor.rgb;
    }

    imageStore(uColorOutput, pixel, vec4(color, 1.0));
}
