#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Buffers and Textures
// ============================================================================

// Depth output (single channel R32F)
layout(r32f, binding = 0) readonly uniform image2D uPreviousLevel;
layout(r32f, binding = 1) writeonly uniform image2D uDepthOutput;

// ============================================================================
// Uniforms
// ============================================================================

#define TOP_LEVEL 7

// Raymarching parameters
uniform float uMaxSteps (1, 800, 100);
uniform float uMaxDistance (1, 100, 10);
uniform float uSurfaceEpsilon (0.1, 5, 1.0);
uniform float uStepRatio (0.1, 1, 1.0);

uniform vec3 uSeed3;
uniform float uLevel;

#include "include/camera.glsl"
#include "include/palette.glsl"
#include "include/distance.glsl"


// ============================================================================
// Base Level Depth Raymarcher (from scratch)
// ============================================================================

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(uDepthOutput);

    // Bounds check
    if (pixel.x >= resolution.x || pixel.y >= resolution.y) {
        return;
    }

    // Generate ray for this pixel at the current mip resolution
    vec3 rayDir = computeRayDirection(pixel, resolution);
    vec3 rayOrigin = uCameraPos;

    float depth = 0.0;
    float t = 0.0; // Start ray at camera

    if (uLevel < TOP_LEVEL)
    {
        // Read previous level depth (nearest neighbor upsampling)
        ivec2 parentPixel = pixel / 2;
        t = imageLoad(uPreviousLevel, parentPixel).r;
        // Step back a little to avoid missing the surface
        t = max(0.0, t - 0.1);
    }

    // Raymarch from scratch
    bool hitSurface = false;

    for (int i = 0; i < uMaxSteps; i++) {
        vec3 pos = rayOrigin + rayDir * t;
        vec2 df_result = mapScene(pos);
        float dist = df_result.x;

        // A more standard hit condition
        if (dist < 0.001 * t) {
            hitSurface = true;
            depth = t;
            break;
        }

        t += dist * uStepRatio;

        if (t >= uMaxDistance) {
            depth = 0.0; // Indicate a miss
            break;
        }
    }

    // Store depth (negative for misses if you want to distinguish them)
    if(hitSurface) {
        imageStore(uDepthOutput, pixel, vec4(depth, 0, 0, 0));
    } else {
        imageStore(uDepthOutput, pixel, vec4(0.0, 0, 0, 0)); // Or a large value for misses
    }
}
