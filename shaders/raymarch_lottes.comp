#version 450 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// ============================================================================
// Space-Filling Curve Functions (for hierarchical ray ordering)
// ============================================================================

// Z-order (Morton) curve - fast bitwise interleaving
uint part1By1(uint x) {
    x &= 0x0000ffffu;
    x = (x ^ (x << 8)) & 0x00ff00ffu;
    x = (x ^ (x << 4)) & 0x0f0f0f0fu;
    x = (x ^ (x << 2)) & 0x33333333u;
    x = (x ^ (x << 1)) & 0x55555555u;
    return x;
}

uint unpart1By1(uint x) {
    x &= 0x55555555u;
    x = (x ^ (x >> 1)) & 0x33333333u;
    x = (x ^ (x >> 2)) & 0x0f0f0f0fu;
    x = (x ^ (x >> 4)) & 0x00ff00ffu;
    x = (x ^ (x >> 8)) & 0x0000ffffu;
    return x;
}

uint xy2morton(uint x, uint y) {
    return part1By1(x) | (part1By1(y) << 1);
}

uvec2 morton2xy(uint m) {
    return uvec2(unpart1By1(m), unpart1By1(m >> 1));
}

// Hilbert curve - better spatial locality
void rot(uint n, inout uint x, inout uint y, uint rx, uint ry) {
    if (ry == 0u) {
        if (rx == 1u) {
            x = n - 1u - x;
            y = n - 1u - y;
        }
        uint t = x;
        x = y;
        y = t;
    }
}

uint xy2hilbert(uint x, uint y, uint n) {
    uint rx, ry, d = 0u;
    uint s = n / 2u;
    while (s > 0u) {
        rx = (x & s) > 0u ? 1u : 0u;
        ry = (y & s) > 0u ? 1u : 0u;
        d += s * s * ((3u * rx) ^ ry);
        rot(n, x, y, rx, ry);
        s = s / 2u;
    }
    return d;
}

uvec2 hilbert2xy(uint d, uint n) {
    uint rx, ry, t = d;
    uint x = 0u, y = 0u;
    uint s = 1u;
    while (s < n) {
        rx = 1u & (t / 2u);
        ry = 1u & (t ^ rx);
        rot(s, x, y, rx, ry);
        x += s * rx;
        y += s * ry;
        t = t / 4u;
        s = s * 2u;
    }
    return uvec2(x, y);
}

// ============================================================================
// Buffers and Textures
// ============================================================================

// Output images
layout(rgba16f, binding = 0) writeonly uniform image2D uOutputImage;
layout(rgba16f, binding = 1) uniform image2D uAccumulationImage;

// Work queue SSBO (shared atomic counter)
layout(std430, binding = 0) buffer WorkQueue {
    uint currentRayIndex;  // Atomically incremented
    uint totalRays;        // Total number of rays to trace
};

// Depth cache SSBO (breadcrumbs from parent cones)
layout(std430, binding = 1) buffer DepthCache {
    float depths[];  // Indexed by ray index
};

// ============================================================================
// Uniforms
// ============================================================================

// Camera
uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

// Scene
uniform vec3 uSphereCenter;
uniform float uSphereRadius;
uniform vec3 uBackgroundColor;

// Viewport
uniform int uViewportWidth;
uniform int uViewportHeight;

// Raymarching parameters
uniform int uMaxSteps;
uniform float uMaxDistance;
uniform float uSurfaceEpsilon;
uniform float uStepRatio;

// Hierarchical raymarching parameters
uniform int uIterationsPerThread;  // Iteration budget per thread
uniform int uFrameNumber;          // For temporal variation
uniform int uCameraChanged;        // Reset accumulation flag (0 or 1)
uniform int uPyramidLevels;        // Number of hierarchy levels (default 3)

// Fractal parameters
uniform vec4 u_paramA;
uniform vec4 u_paramB;
uniform vec4 u_paramC;
uniform float _LEVELS;

// ============================================================================
// Hierarchical Ray Ordering
// ============================================================================

// Find next power of 2
uint nextPow2(uint x) {
    uint n = 1u;
    while (n < x) {
        n = n * 2u;
    }
    return n;
}

// Compute pixel coordinate from hierarchical ray index
// Level 0: 1/16th of pixels (every 4x4 block centers)
// Level 1: 1/4th of pixels (every 2x2 block centers)
// Level 2: All pixels (full resolution)
// Uses simple scan-line order for guaranteed rectangular coverage
ivec2 computeHierarchicalPixel(uint rayIndex) {
    uint width = uint(uViewportWidth);
    uint height = uint(uViewportHeight);

    // Calculate number of rays per level
    uint raysPerLevel0 = (width / 4u) * (height / 4u);
    uint raysPerLevel1 = (width / 2u) * (height / 2u);
    uint raysPerLevel2 = width * height;

    ivec2 pixel;

    if (rayIndex < raysPerLevel0) {
        // Level 0: Coarse (every 4x4 block) - scan-line order
        uint coarseWidth = width / 4u;
        uint coarseHeight = height / 4u;

        uint coarseX = rayIndex % coarseWidth;
        uint coarseY = rayIndex / coarseWidth;

        pixel = ivec2(coarseX * 4u + 2u, coarseY * 4u + 2u);  // Center of 4x4 block
    }
    else if (rayIndex < raysPerLevel0 + raysPerLevel1) {
        // Level 1: Medium (every 2x2 block) - scan-line order
        uint mediumIndex = rayIndex - raysPerLevel0;
        uint mediumWidth = width / 2u;
        uint mediumHeight = height / 2u;

        uint mediumX = mediumIndex % mediumWidth;
        uint mediumY = mediumIndex / mediumWidth;

        pixel = ivec2(mediumX * 2u + 1u, mediumY * 2u + 1u);  // Center of 2x2 block
    }
    else {
        // Level 2: Fine (all pixels) - scan-line order
        uint fineIndex = rayIndex - raysPerLevel0 - raysPerLevel1;

        uint fineX = fineIndex % width;
        uint fineY = fineIndex / width;

        pixel = ivec2(fineX, fineY);
    }

    return pixel;
}

// Get parent ray index for breadcrumb lookup
// Maps pixel coordinates to parent blocks using scan-line order
uint getParentIndex(uint rayIndex, ivec2 pixel) {
    uint width = uint(uViewportWidth);
    uint height = uint(uViewportHeight);

    uint raysPerLevel0 = (width / 4u) * (height / 4u);
    uint raysPerLevel1 = (width / 2u) * (height / 2u);

    if (rayIndex < raysPerLevel0) {
        // Level 0 has no parent
        return 0xFFFFFFFFu;
    }
    else if (rayIndex < raysPerLevel0 + raysPerLevel1) {
        // Level 1's parent is in level 0
        // Find which 4x4 block this pixel belongs to
        uint parentX = uint(pixel.x) / 4u;
        uint parentY = uint(pixel.y) / 4u;
        uint coarseWidth = width / 4u;

        // Convert parent coordinates to ray index via scan-line order
        return parentY * coarseWidth + parentX;
    }
    else {
        // Level 2's parent is in level 1
        // Find which 2x2 block this pixel belongs to
        uint parentX = uint(pixel.x) / 2u;
        uint parentY = uint(pixel.y) / 2u;
        uint mediumWidth = width / 2u;

        // Convert parent coordinates to ray index via scan-line order
        uint parentInLevel1 = parentY * mediumWidth + parentX;
        return raysPerLevel0 + parentInLevel1;
    }
}

// ============================================================================
// Distance Functions
// ============================================================================

// vec2 pseudo_knightyan(vec3 p)
// {
//     vec3 CSize = u_paramA.xyz;
//     float DEfactor = 1.;
//     float orbit = 0;
//     for (int i = 0; i < 6; i++)
//     {

//         vec3 start = p;
//         p = 2. * clamp(p, -CSize, CSize) - p;
//         p = rotateX(p, u_paramB.x);
//         p = rotateY(p, u_paramB.y);
//         p = rotateZ(p, u_paramB.z);
//         float k = max(u_paramC.x / dot(p, p), 1.);
//         p *= k;
//         DEfactor *= k + 0.05;

//         orbit += length(start - p);
//     }
//     float rxy = length(p.xy);
//     float ds = max(rxy - 0.92784, abs(rxy * p.z) / length(p)) / DEfactor;

//     return vec2(ds, orbit);
// }

// vec2 tglad_variant(vec3 z0)
// {
//     // z0 = modc(z0, 2.0);
//     float mr = u_paramD.x, mxr = u_paramD.y;

//     vec4 scale = (vec4) (u_paramD.z), p0 = u_paramA.xyzz;
//     vec4 z = vec4(z0, 1.0);
//     float orbit = 0;
//     for (int n = 0; n < _LEVELS; n++)
//     {
//         vec3 start = z;
//         z.xyz = clamp(z.xyz, -u_paramB.x, u_paramB.x) * 2.0 - z.xyz;
//         z *= scale / clamp(dot(z.xyz, z.xyz), mr, mxr);
//         z += p0;
//         orbit += length(start - z);
//     }
//     float dS = (length(max(abs(z.xyz) - u_paramC.xyz, 0.0)) - 0) / z.w;
//     return vec2(dS, orbit);
// }

vec2 tglad(vec3 z0)
{

    int _LEVELS = 6;
    vec4 u_paramA = vec4(3.0, 1.0, 0.0, 0.0);
    vec4 u_paramB = vec4(1.0, 0.0, 0.0, 0.0);
    vec4 u_paramC = vec4(1.2, 49.0, 1.4, 0.0);

    // z0 = modc(z0, 2.0);

    float mr = 0.25, mxr = 1.0;
    vec4 scale = vec4(-3.12, -3.12, -3.12, 3.12), p0 = u_paramA.xyzz;
    vec4 z = vec4(z0, 1.0);
    float orbit = 0;

    for (int n = 0; n < _LEVELS; n++)
    {
        vec3 start = z.xyz;

        z.xyz = clamp(z.xyz, -u_paramB.x, u_paramB.x) * 2.0 - z.xyz;
        z *= scale / clamp(dot(z.xyz, z.xyz), mr, mxr);
        z += p0;
        orbit += length(start - z.xyz);
    }

    float dS = (length(max(abs(z.xyz) - vec3(1.2, 49.0, 1.4), 0.0)) - 0.06) / z.w;
    return vec2(dS, orbit);
}

// // distance function from Hartverdrahtet
// // ( http://www.pouet.net/prod.php?which=59086 )
// vec2 hartverdrahtet(vec3 f)
// {
//     vec3 cs = u_paramA.xyz;
//     float fs = u_paramC.x;
//     vec3 fc = 0;
//     float fu = 10.;
//     float fd = .763;
//     float orbit = 0.0;
//     fc.z = -.38;
//     float v = 1.;
//     for (int i = 0; i < _LEVELS; i++)
//     {
//         vec3 start = f;
//         f = 2. * clamp(f, -cs, cs) - f;
//         float c = max(fs / dot(f, f), 1.);
//         f *= c;
//         v *= c;
//         f += fc;
//         orbit += length(start - f);
//     }
//     float z = length(f.xy) - fu;
//     float d = fd * max(z, abs(length(f.xy) * f.z) / sqrt(dot(f, f))) / abs(v);

//     return vec2(d, orbit);
// }

vec2 mapScene(vec3 p)
{
    return tglad(p);
}

// returns depth, iterations, and orbit
vec3 raymarch(vec3 ro, vec3 rd)
{
    float depth = 0.0;
    for (int i = 0; i < uMaxSteps; ++i)
    {
        vec3 pos = ro + rd * depth;
        vec2 df_result = mapScene(pos);
        float dist = df_result.x;
        if (dist < uSurfaceEpsilon)
        {
            return vec3(depth, float(i), df_result.y);
        }
        depth += dist * uStepRatio;
        if (depth >= uMaxDistance)
        {
            break;
        }
    }
    return vec3(-1.0, float(uMaxSteps), 1);
}


vec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)
{
    return a + b * cos(6.28318 * (c * t + d));
}

vec3 palette(float t)
{
    float _Palette = 2.0;
    vec2 _ColorParam = vec2(0.01, 0.0);
    t = (t * _ColorParam.x) + _ColorParam.y;
    vec3 color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.33, 0.67));
    if (_Palette > (1.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.10, 0.20));
    if (_Palette > (2.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.3, 0.20, 0.20));
    if (_Palette > (3.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 0.5), vec3(0.8, 0.90, 0.30));
    if (_Palette > (4.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 0.7, 0.4), vec3(0.0, 0.15, 0.20));
    if (_Palette > (5.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));
    if (_Palette > (5.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));
    if (_Palette > (6.0))
        color = vec3(1.0);

    return color;
}

vec3 estimateNormal(vec3 p)
{
    const float h = 0.001;
    vec2 e = vec2(0.01, -1.0);
    return normalize(
        e.xyy * mapScene(p + e.xyy * h).x +
        e.yyx * mapScene(p + e.yyx * h).x +
        e.yxy * mapScene(p + e.yxy * h).x +
        e.xxx * mapScene(p + e.xxx * h).x
    );
}

// ============================================================================
// Ray Generation
// ============================================================================

vec3 computeRayDirection(ivec2 pixel) {
    vec2 resolution = vec2(float(uViewportWidth), float(uViewportHeight));
    vec2 uv = (vec2(pixel) + vec2(0.5)) / resolution;
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    return normalize(
        uCameraForward +
        ndcX * uTanHalfFov * uAspect * uCameraRight +
        -ndcY * uTanHalfFov * uCameraUp
    );
}

// ============================================================================
// Shading
// ============================================================================

vec3 shade(vec3 hitPos, float orbit) {
    vec3 normal = estimateNormal(hitPos);
    vec3 lightDir = normalize(vec3(0.4, 0.8, 0.2));
    float diffuse = max(dot(normal, lightDir), 0.0);
    vec3 baseColor = palette(orbit);
    return baseColor * diffuse + baseColor * 0.1;
}

// ============================================================================
// Hierarchical Raymarcher Main
// ============================================================================

void main()
{
    uint threadId = gl_GlobalInvocationID.x;

    // Each thread has an iteration budget
    int iterationsRemaining = uIterationsPerThread;

    // Work queue loop - keep marching rays until budget exhausted
    while (iterationsRemaining > 0) {
        // Atomically grab next ray from queue
        uint rayIdx = atomicAdd(currentRayIndex, 1);

        // Check if all rays complete
        if (rayIdx >= totalRays) {
            return;  // No more rays, thread exits
        }

        // Compute pixel from hierarchical ray index
        ivec2 pixel = computeHierarchicalPixel(rayIdx);

        // With scan-line order, pixels are always in bounds (no need for bounds check)
        // Generate ray for this pixel
        vec3 rayDir = computeRayDirection(pixel);
        vec3 rayOrigin = uCameraPos;
        float depth = 0.0;

        // Check for parent breadcrumb
        uint parentIdx = getParentIndex(rayIdx, pixel);
        uint width = uint(uViewportWidth);
        uint height = uint(uViewportHeight);
        uint raysPerLevel0 = (width / 4u) * (height / 4u);

        // Only use breadcrumb if parent exists and has been processed
        if (parentIdx != 0xFFFFFFFFu &&
            parentIdx < totalRays &&
            ((rayIdx >= raysPerLevel0 && parentIdx < raysPerLevel0) ||  // Level 1 reading Level 0
             (rayIdx >= raysPerLevel0 + (width/2u)*(height/2u) && parentIdx < raysPerLevel0 + (width/2u)*(height/2u)))) { // Level 2 reading Level 1
            float parentDepth = depths[parentIdx];
            if (parentDepth > 0.0) {
                // Parent hit something - start slightly before parent's depth
                // (small negative offset accounts for surface approximation error)
                depth = 0.0;
                float startDepth = max(0.0, parentDepth - 0.1);
                rayOrigin = uCameraPos + rayDir * startDepth;
            }
        }

        // Raymarch this ray for limited iterations
        bool hitSurface = false;
        float orbit = 0.0;
        int maxItersForRay = min(uMaxSteps, iterationsRemaining);

        int i = 0;
        while (i < maxItersForRay) {
            vec3 pos = rayOrigin + rayDir * depth;
            vec3 df_result = mapScene(pos);
            float dist = df_result.x;
            orbit = df_result.y;

            iterationsRemaining--;
            i++;

            if (dist < uSurfaceEpsilon) {
                hitSurface = true;
                break;
            }

            depth += dist * uStepRatio;

            if (depth >= uMaxDistance) {
                break;  // Ray escaped
            }
        }

        // Compute color for this ray
        vec3 color;
        if (hitSurface) {
            vec3 hitPos = uCameraPos + rayDir * depth;
            color = shade(hitPos, orbit);
            depths[rayIdx] = depth;  // Leave breadcrumb
        } else {
            color = uBackgroundColor;
            depths[rayIdx] = -1.0;  // Mark as miss
        }

        // Temporal accumulation
        if (uCameraChanged) {
            // Camera moved - write fresh sample
            imageStore(uOutputImage, pixel, vec4(color, 1.0));
            imageStore(uAccumulationImage, pixel, vec4(color, 1.0));
        } else {
            // Camera static - check if this pixel was rendered before
            vec4 prevColor = imageLoad(uAccumulationImage, pixel);

            if (prevColor.a > 0.0) {
                // Pixel was rendered before - accumulate for temporal AA
                float n = float(uFrameNumber);
                vec4 accumulated = (prevColor * n + vec4(color, 1.0)) / (n + 1.0);

                imageStore(uOutputImage, pixel, accumulated);
                imageStore(uAccumulationImage, pixel, accumulated);
            } else {
                // First time rendering this pixel during progressive refinement
                // Write directly without accumulation
                imageStore(uOutputImage, pixel, vec4(color, 1.0));
                imageStore(uAccumulationImage, pixel, vec4(color, 1.0));
            }
        }
    }

    // Iteration budget exhausted - thread exits
    // Some rays may still be unprocessed (will appear in next frame)
}
