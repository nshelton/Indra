#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba16f, binding = 0) writeonly uniform image2D uOutputImage;
uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

uniform vec3 uSphereCenter;
uniform float uSphereRadius;
uniform vec3 uBackgroundColor;

uniform int uViewportWidth;
uniform int uViewportHeight;
uniform int uMaxSteps;
uniform float uMaxDistance;
uniform float uSurfaceEpsilon;

uniform vec4 u_paramA;
uniform vec4 u_paramB;
uniform vec4 u_paramC;

uniform float _LEVELS;
uniform float uStepRatio;


// vec2 pseudo_knightyan(vec3 p)
// {
//     vec3 CSize = u_paramA.xyz;
//     float DEfactor = 1.;
//     float orbit = 0;
//     for (int i = 0; i < 6; i++)
//     {

//         vec3 start = p;
//         p = 2. * clamp(p, -CSize, CSize) - p;
//         p = rotateX(p, u_paramB.x);
//         p = rotateY(p, u_paramB.y);
//         p = rotateZ(p, u_paramB.z);
//         float k = max(u_paramC.x / dot(p, p), 1.);
//         p *= k;
//         DEfactor *= k + 0.05;

//         orbit += length(start - p);
//     }
//     float rxy = length(p.xy);
//     float ds = max(rxy - 0.92784, abs(rxy * p.z) / length(p)) / DEfactor;

//     return vec2(ds, orbit);
// }

// vec2 tglad_variant(vec3 z0)
// {
//     // z0 = modc(z0, 2.0);
//     float mr = u_paramD.x, mxr = u_paramD.y;

//     vec4 scale = (vec4) (u_paramD.z), p0 = u_paramA.xyzz;
//     vec4 z = vec4(z0, 1.0);
//     float orbit = 0;
//     for (int n = 0; n < _LEVELS; n++)
//     {
//         vec3 start = z;
//         z.xyz = clamp(z.xyz, -u_paramB.x, u_paramB.x) * 2.0 - z.xyz;
//         z *= scale / clamp(dot(z.xyz, z.xyz), mr, mxr);
//         z += p0;
//         orbit += length(start - z);
//     }
//     float dS = (length(max(abs(z.xyz) - u_paramC.xyz, 0.0)) - 0) / z.w;
//     return vec2(dS, orbit);
// }

vec2 tglad(vec3 z0)
{

    int _LEVELS = 6;
    vec4 u_paramA = vec4(3.0, 1.0, 0.0, 0.0);
    vec4 u_paramB = vec4(1.0, 0.0, 0.0, 0.0);
    vec4 u_paramC = vec4(1.2, 49.0, 1.4, 0.0);

    // z0 = modc(z0, 2.0);

    float mr = 0.25, mxr = 1.0;
    vec4 scale = vec4(-3.12, -3.12, -3.12, 3.12), p0 = u_paramA.xyzz;
    vec4 z = vec4(z0, 1.0);
    float orbit = 0;

    for (int n = 0; n < _LEVELS; n++)
    {
        vec3 start = z.xyz;

        z.xyz = clamp(z.xyz, -u_paramB.x, u_paramB.x) * 2.0 - z.xyz;
        z *= scale / clamp(dot(z.xyz, z.xyz), mr, mxr);
        z += p0;
        orbit += length(start - z.xyz);
    }

    float dS = (length(max(abs(z.xyz) - vec3(1.2, 49.0, 1.4), 0.0)) - 0.06) / z.w;
    return vec2(dS, orbit);
}

// // distance function from Hartverdrahtet
// // ( http://www.pouet.net/prod.php?which=59086 )
// vec2 hartverdrahtet(vec3 f)
// {
//     vec3 cs = u_paramA.xyz;
//     float fs = u_paramC.x;
//     vec3 fc = 0;
//     float fu = 10.;
//     float fd = .763;
//     float orbit = 0.0;
//     fc.z = -.38;
//     float v = 1.;
//     for (int i = 0; i < _LEVELS; i++)
//     {
//         vec3 start = f;
//         f = 2. * clamp(f, -cs, cs) - f;
//         float c = max(fs / dot(f, f), 1.);
//         f *= c;
//         v *= c;
//         f += fc;
//         orbit += length(start - f);
//     }
//     float z = length(f.xy) - fu;
//     float d = fd * max(z, abs(length(f.xy) * f.z) / sqrt(dot(f, f))) / abs(v);

//     return vec2(d, orbit);
// }

vec2 mapScene(vec3 p)
{
    return tglad(p);
}

float raymarch(vec3 ro, vec3 rd)
{
    float depth = 0.0;
    for (int i = 0; i < uMaxSteps; ++i)
    {
        vec3 pos = ro + rd * depth;
        float dist = mapScene(pos).x;
        if (dist < uSurfaceEpsilon)
        {
            return depth;
        }
        depth += dist * uStepRatio;
        if (depth >= uMaxDistance)
        {
            break;
        }
    }
    return -1.0;
}


vec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)
{
    return a + b * cos(6.28318 * (c * t + d));
}

vec3 palette(float t)
{
    float _Palette = 2.0;
    vec2 _ColorParam = vec2(0.01, 0.0);
    t = (t * _ColorParam.x) + _ColorParam.y;
    vec3 color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.33, 0.67));
    if (_Palette > (1.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.10, 0.20));
    if (_Palette > (2.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.3, 0.20, 0.20));
    if (_Palette > (3.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 0.5), vec3(0.8, 0.90, 0.30));
    if (_Palette > (4.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 0.7, 0.4), vec3(0.0, 0.15, 0.20));
    if (_Palette > (5.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));
    if (_Palette > (5.0)) color = pal(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));
    if (_Palette > (6.0))
        color = vec3(1.0);

    return color;
}

vec3 estimateNormal(vec3 p)
{
    const float h = 0.001;
    vec2 e = vec2(0.01, -1.0);
    return normalize(
        e.xyy * mapScene(p + e.xyy * h).x +
        e.yyx * mapScene(p + e.yyx * h).x +
        e.yxy * mapScene(p + e.yxy * h).x +
        e.xxx * mapScene(p + e.xxx * h).x
    );
}

void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= uint(uViewportWidth) || gid.y >= uint(uViewportHeight))
    {
        return;
    }

    vec2 resolution = vec2(float(uViewportWidth), float(uViewportHeight));
    vec2 uv = (vec2(gid) + vec2(0.5)) / resolution;
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    vec3 rayDir = normalize(
        uCameraForward +
        ndcX * uTanHalfFov * uAspect * uCameraRight +
        -ndcY * uTanHalfFov * uCameraUp
    );

    float hit = raymarch(uCameraPos, rayDir);
    vec3 color = uBackgroundColor;

    if (hit > 0.0)
    {
        vec3 hitPos = uCameraPos + rayDir * hit;
        vec3 normal = estimateNormal(hitPos);
        vec3 lightDir = normalize(vec3(0.4, 0.8, 0.2));
        float diffuse = max(dot(normal, lightDir), 0.0);
        vec3 baseColor = palette(mapScene(hitPos).y );
        color = baseColor * diffuse + baseColor * 0.1;
    }

    imageStore(uOutputImage, ivec2(gid), vec4(color, 1.0));
}
