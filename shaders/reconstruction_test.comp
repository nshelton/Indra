#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ============================================================================
// Buffers and Textures
// ============================================================================

// Depth input (from raymarching passes)
layout(rgba16f, binding = 0) readonly uniform image2D u_thisFrameShaded;
layout(rgba16f, binding = 1) readonly uniform image2D u_lastFrameShaded;

// Color output
layout(rgba16f, binding = 2) writeonly uniform image2D uColorOutput;

// ============================================================================
// Uniforms
// ============================================================================

// Viewport
uniform ivec2 uViewportSize;

uniform vec3 uCameraPos;
uniform vec3 uCameraForward;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;
uniform float uTanHalfFov;
uniform float uAspect;

vec3 computeRayDirection(ivec2 pixel, ivec2 resolution) {
    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(resolution);
    float ndcX = uv.x * 2.0 - 1.0;
    float ndcY = 1.0 - uv.y * 2.0;

    return normalize( vec3(
        ndcX * uTanHalfFov * uAspect,
        -ndcY * uTanHalfFov,
        -1
    ));
}

vec2 projectToPixel(vec3 localPos, ivec2 resolution) {
    // Transform world position to camera/view space
    // Perspective divide
    float ndcX = -localPos.x / (localPos.z * uTanHalfFov * uAspect);
    float ndcY = localPos.y / (localPos.z * uTanHalfFov);
    // NDC to UV to pixel
    vec2 uv = vec2(
        (ndcX + 1.0) * 0.5,
        (1.0 - ndcY) * 0.5
    );
    return uv * vec2(resolution) - 0.5;
}

uniform mat4 uThisFrameToLastFrame;

void main()
{
   ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(uDepthOutput);

    // Bounds check
    if (pixel.x >= resolution.x || pixel.y >= resolution.y) {
        return;
    }

    // Generate ray for this pixel at the current mip resolution
    // Each mip level covers the full viewport, just at different resolutions
    vec3 rayDir = computeRayDirection(pixel, resolution);
    vec3 rayOrigin = uCameraPos;

    float depth = 0.0;

    // Raymarch from scratch
    bool hitSurface = false;

    for (int i = 0; i < uMaxSteps; i++) {
        vec3 pos = rayOrigin + rayDir * depth;
        vec2 df_result = mapScene(pos);
        float dist = df_result.x;

        if (dist < exp(-uSurfaceEpsilon) * (1 << uLevel) * depth) {
            hitSurface = true;
            break;
        }

        depth += dist * uStepRatio;

        if (depth >= uMaxDistance) {
            depth = uMaxDistance;
            break;
        }
    }

    // Store depth (negative for misses if you want to distinguish them)
    imageStore(uDepthOutput, pixel, vec4(depth, 0, 0, 0));
}